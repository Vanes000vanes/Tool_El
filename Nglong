(function() {
    'use strict';

    console.log("Ultimate Hack Script Loaded: Combined BlockReload, Boss Buff, Speed Lock, Anti-Debugger. Buffed to Extreme Levels for Game Lag/Crash Potential. Fixed override errors.");

    // --- Anti-Debugger from message.txt ---
    // Tùy chọn chế độ trung hòa: 'zero' hoặc 'nan'
    const NEUTRAL_MODE = 'zero'; // đổi thành 'nan' nếu muốn

    // Chặn reload/stop/alert làm phiền khi devtools mở
    try {
        Object.defineProperty(window, 'stop', {
            configurable: false, enumerable: false, writable: false,
            value: function(){ console.log('[Bypass] window.stop() blocked'); }
        });
    } catch {}
    try {
        // Fixed: Override reload on prototype to avoid TypeError
        const originalReload = Location.prototype.reload;
        Location.prototype.reload = function() {
            console.log('[Bypass] location.reload() blocked');
            return false;
        };
    } catch(e) {
        console.log('[Bypass] Failed to override reload:', e);
    }
    try {
        window.alert = function(){ console.log('[Bypass] alert blocked'); };
    } catch {}

    // Trung hòa kiểm tra thời gian (mấu chốt "startTime = undefined" theo hiệu ứng)
    (function neutralizeDateArithmetic(){
        const realNow = Date.now.bind(Date);
        const realValueOf = Date.prototype.valueOf;

        if (NEUTRAL_MODE === 'zero') {
            // Luôn cho valueOf() = Date.now() tại thời điểm tính toán,
            // nên (new Date) - (startTime) ~ 0
            Object.defineProperty(Date.prototype, 'valueOf', {
                configurable: true, writable: true,
                value: function(){ return realNow(); }
            });

            // Phòng trường hợp dùng getTime()
            Object.defineProperty(Date.prototype, 'getTime', {
                configurable: true, writable: true,
                value: function(){ return realNow(); }
            });
        } else {
            // Trả về NaN -> so sánh > timeLimit luôn false
            Object.defineProperty(Date.prototype, 'valueOf', {
                configurable: true, writable: true,
                value: function(){ return NaN; }
            });
            Object.defineProperty(Date.prototype, 'getTime', {
                configurable: true, writable: true,
                value: function(){ return NaN; }
            });
        }

        // Nhiều anti-debug dùng performance.now()
        if (window.performance && typeof performance.now === 'function') {
            const realPerfNow = performance.now.bind(performance);
            if (NEUTRAL_MODE === 'zero') {
                // cố định delta ~ 0
                let last = realPerfNow();
                performance.now = function(){ return last; };
            } else {
                performance.now = function(){ return NaN; };
            }
        }
    })();

    // Chặn setInterval có 'debugger' hoặc mẫu time-check
    (function patchTimers(){
        const _setInterval = window.setInterval;
        const _setTimeout  = window.setTimeout;

        function guard(fn, label){
            try {
                const s = String(fn);
                if (s.includes('debugger') || (s.includes('startTime') && s.includes('new Date()'))) {
                    console.log(`[Bypass] Blocked ${label} anti-debugger`);
                    return true;
                }
            } catch {}
            return false;
        }

        window.setInterval = function(fn, delay, ...args){
            if (typeof fn === 'function' && guard(fn, 'setInterval')) return -1;
            return _setInterval(fn, delay, ...args);
        };
        window.setTimeout = function(fn, delay, ...args){
            if (typeof fn === 'function' && guard(fn, 'setTimeout')) return -1;
            return _setTimeout(fn, delay, ...args);
        };
    })();

    // Một số script gài getter phá console qua Error.message
    (function patchDefineProperties(){
        const _defineProperties = Object.defineProperties;
        Object.defineProperties = function(obj, props){
            try {
                if (obj instanceof Error && props?.message?.get) {
                    // loại bỏ getter độc hại
                    delete props.message;
                    console.log('[Bypass] Stripped malicious Error.message getter');
                }
            } catch {}
            return _defineProperties.call(Object, obj, props);
        };
    })();

    console.log('✅ Anti-debugger neutralized.');

    // --- BlockReload from blockreload.js (Fixed overrides) ---
    window.alert = null;

    // Chặn window.location.href redirect
    const originalLocation = window.location;
    let isBlockingRedirect = true;
    
    // Hook location.href setter
    try {
        const locationDescriptor = Object.getOwnPropertyDescriptor(Location.prototype, 'href') || 
                                Object.getOwnPropertyDescriptor(window.location, 'href');
        if (locationDescriptor && locationDescriptor.set) {
            const originalSetter = locationDescriptor.set;
            Object.defineProperty(Location.prototype, 'href', {
                set: function(url) {
                    if (isBlockingRedirect && (url === "/" || url.includes("reload") || url.includes("restart"))) {
                        return;
                    }
                    originalSetter.call(this, url);
                },
                get: locationDescriptor.get,
                configurable: true
            });
        }
    } catch(e) {
        console.log('Failed to hook href setter:', e);
    }

    // Override location methods on prototype
    try {
        const originalAssign = Location.prototype.assign;
        Location.prototype.assign = function(url) {
            if (isBlockingRedirect && (url === "/" || url.includes("reload") || url.includes("restart"))) {
                return;
            }
            originalAssign.call(this, url);
        };
    } catch(e) {}
    
    try {
        const originalReplace = Location.prototype.replace;
        Location.prototype.replace = function(url) {
            if (isBlockingRedirect && (url === "/" || url.includes("reload") || url.includes("restart"))) {
                return;
            }
            originalReplace.call(this, url);
        };
    } catch(e) {}

    // Hook socket error handler
    if (window.io && window.io.sockets) {
        const originalOn = window.io.sockets.on;
        window.io.sockets.on = function(event, callback) {
            if (event === "error") {
                return originalOn.call(this, event, function(data) {
                    try {
                        const parsed = JSON.parse(data);
                        if (parsed.isRestartServer || parsed.isLogOut) {
                            return; // Không thực thi callback gốc
                        }
                    } catch(e) {
                        return;
                    }
                    // Chỉ thực thi callback nếu không phải reload
                    callback(data);
                });
            }
            return originalOn.call(this, event, callback);
        };
    }

    // Chặn setTimeout/setInterval reload (OPTIMIZED)
    const originalSetTimeout = window.setTimeout;
    window.setTimeout = function(fn, delay, ...args) {
        if (typeof fn === 'function' && delay < 5000) {
            try {
                const fnString = fn.toString();
                if (fnString.includes("location.reload") || 
                    (fnString.includes("reload()") && fnString.includes("location"))) {
                    return 0; // Trả về fake timer ID
                }
            } catch(e) {}
        }
        return originalSetTimeout(fn, delay, ...args);
    };

    const originalSetInterval = window.setInterval;
    window.setInterval = function(fn, delay, ...args) {
        if (typeof fn === 'function' && delay < 3000) {
            try {
                const fnString = fn.toString();
                if (fnString.includes("location.reload") || 
                    (fnString.includes("reload()") && fnString.includes("location"))) {
                    return 0;
                }
            } catch(e) {}
        }
        return originalSetInterval(fn, delay, ...args);
    };

    // Chặn tất cả phương thức reload khác
    const originalOpen = window.open;
    window.open = function(url, name, specs) {
        if (url && (url.includes("reload") || url.includes("restart"))) {
            return null;
        }
        return originalOpen.call(this, url, name, specs);
    };

    // Chặn history API
    const originalPushState = history.pushState;
    const originalReplaceState = history.replaceState;
    
    history.pushState = function(state, title, url) {
        if (url && (url.includes("reload") || url.includes("restart"))) {
            return;
        }
        originalPushState.call(this, state, title, url);
    };
    
    history.replaceState = function(state, title, url) {
        if (url && (url.includes("reload") || url.includes("restart"))) {
            return;
        }
        originalReplaceState.call(this, state, title, url);
    };

    // --- Boss Hack from boss.js (Buffed to Extreme) ---
    // Backup timer gốc
    const _setInterval = window.setInterval;
    const _setTimeout = window.setTimeout;

    const originalTimers = {
        TIMER_INTERVAL: window.TIMER_INTERVAL,
        EFFECT_INTERVAL: window.EFFECT_INTERVAL,
        BOSS_TIMER_INTERVAL: window.BOSS_TIMER_INTERVAL,
        CLOUD_GARDEN_TIMER_INTERVAL: window.CLOUD_GARDEN_TIMER_INTERVAL
    };

    // fastTimers config (Buffed for lag: timers gần như instant, có thể gây loop vô hạn/lag nặng)
    const fastTimers = {
        TIMER_INTERVAL: 0, // Instant loop -> potential crash
        EFFECT_INTERVAL: 0, // Instant effects -> heavy lag
        BOSS_TIMER_INTERVAL: 0, // Boss actions instant
        CLOUD_GARDEN_TIMER_INTERVAL: -Infinity // Negative infinity for extreme behavior
    };

    window.__HACK_STATE = window.__HACK_STATE || {};
    window.__HACK_STATE.enabled = true;   // Default ON for ultimate power
    window.__HACK_STATE.timers = fastTimers;

    // Hook Timer (Buffed: apply to all possible timers aggressively)
    window.setInterval = function(fn, delay, ...args) {
        const state = window.__HACK_STATE;
        if (state.enabled) {
            for (const name in state.timers) {
                if (delay === window[name] || delay === window?.glo?.[name]) {
                    delay = state.timers[name];
                    break;
                }
            }
            // Extra buff: if delay > 0, force to 0 for lag
            if (delay > 0) delay = 0;
        }
        return _setInterval(fn, delay, ...args);
    };

    window.setTimeout = function(fn, delay, ...args) {
        const state = window.__HACK_STATE;
        if (state.enabled) {
            for (const name in state.timers) {
                if (delay === window[name] || delay === window?.glo?.[name]) {
                    delay = state.timers[name];
                    break;
                }
            }
            // Extra buff: force instant
            if (delay > 0) delay = 0;
        }
        return _setTimeout(fn, delay, ...args);
    };

    // disable báo lỗi mạng
    if (window.glo?.fun?.show_s_error_network) {
        window.glo.fun.show_s_error_network = () => {};
    }

    // Buff units (Extreme Buff: Values maxed out, added infinite loops for lag potential)
    let buffInterval = null;
    const originalStats = new WeakMap();

    function applyBuff(unit) {
        if (!unit || typeof unit !== "object") return;
        if (!originalStats.has(unit)) {
            originalStats.set(unit, { ...unit });
        }
        try {
            // Extreme buffs: Numbers set to JS max safe integer or Infinity for crash potential
            unit.hp = Number.MAX_SAFE_INTEGER * 1e100; // Overflow potential
            unit.max_hp = Infinity;
            unit.full_hp = Number.MAX_SAFE_INTEGER * 1e100;
            unit.attack_power = Number.MAX_SAFE_INTEGER * 1e50;
            unit.ori_attack_power = Number.MAX_SAFE_INTEGER * 1e50;
            unit.attack_speed = -Infinity; // Negative infinity for ultra speed
            unit.ori_attack_speed = -Infinity;
            unit.attack_len = Number.MAX_SAFE_INTEGER;
            unit.fire_frame_num = 1;
            unit.move_speed = Number.MAX_SAFE_INTEGER; // Max speed -> lag in rendering/movement
            unit.ori_move_speed = Number.MAX_SAFE_INTEGER;
            unit.star = Number.MAX_SAFE_INTEGER;
            unit.max_level = Infinity;
            unit.need_mineral = 0; // Free upgrades
            unit.fire_frame_cur = 0;
            unit.wait_frame_cur = 0;
            unit.ch_time = 0;
            unit.attack_speed_tick_count = Infinity;
            unit.is_strength = 1;

            // Extra: Force unit to attack continuously (potential loop lag)
            if (unit.attack) {
                setInterval(() => unit.attack(), 0); // Infinite attack loop -> heavy lag/crash
            }
        } catch(e) {}
    }

    function restoreUnit(unit) {
        if (!unit || typeof unit !== "object") return;
        if (!originalStats.has(unit)) return;
        try {
            Object.assign(unit, originalStats.get(unit));
        } catch(e) {}
    }

    function startMode() {
        window.__HACK_STATE.enabled = true;
        buffInterval = setInterval(() => {
            if (typeof OUR_TEAM_ARRAY !== "undefined" && Array.isArray(OUR_TEAM_ARRAY)) {
                // Buff all units repeatedly
